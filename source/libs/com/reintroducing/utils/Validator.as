package com.reintroducing.utils{	import flash.utils.getQualifiedClassName;		/**	 * Static utility methods for validating data.	 *  	 * @author Matt Przybylski [http://www.reintroducing.com] (AS3 version) 	 * @version 1.0 	 */	public class Validator 	{//- PRIVATE & PROTECTED VARIABLES -------------------------------------------------------------------------		private static const STATES:String = " AL AK AS AZ AR CA CO CT DE DC FM FL GA GU HI ID IL IN IA KS KY LA ME MH MD MA MI MN MS MO MT NE NV NH NJ NM NY NC ND MP OH OK OR PW PA PR RI SC SD TN TX UT VT VI VA WA WV WI WY ";		private static const PHONE_REG_EXP:RegExp = /^((\+\d{1,3}(-| )?\(?\d\)?(-| )?\d{1,3})|(\(?\d{2,3}\)?))(-| )?(\d{3,4})(-| )?(\d{4})(( x| ext)\d{1,5}){0,1}$/i;		private static const ZIP_REG_EXP:RegExp   = /^\d{5}([\-]\d{4})?$/;		private static const PO_BOX_REG_EXP:RegExp = /^\s*((P(OST)?.?\s*O(FF(ICE)?)?.?\s+(B(IN|OX))?)|B(IN|OX))/i;				private static var _illegalWords:Array;		//- PUBLIC & INTERNAL VARIABLES ---------------------------------------------------------------------------						//- CONSTRUCTOR	-------------------------------------------------------------------------------------------			public function Validator()		{			_illegalWords = [	"FUCK",								"F-U-C-K",								"F U C K",								"F*U*C*K",								"F_U_C_K",							  	"SHIT",							  	"S H I T",							 	"S-H-I-T",							  	"SHITTY",							  	"BULLSHIT",							  	"COCK",							  	"C O C K",							  	"C-O-C-K",							  	"CUNT",							  	"C U N T",							  	"C-U-N-T",							  	"BITCH",							  	"COCKSUCKER",							  	"PENIS",							  	"PUSSY",							  	"WHORE",							  	"TITS",							  	"LAID",							  	"PISS",							  	"ASSHOLE",							  	"ASS HOLE",							  	"BEANER",							  	"CHINK",							  	"COON",							  	"DAGO",							  	"DARKIE",							  	"GOOK",							  	"HEEB",							  	"JIGABOO",							  	"JUNGLE BUNNY",							  	"KYKE",							  	"NIGGER",							  	"NIP",							  	"POLACK",							  	"SAMBO",							  	"SAND-NIGGER",							  	"SPIC",							  	"TOWEL-HEAD",							  	"WET BACK",							  	"WOP",							  	"YID",							  	"JEW",							  	"DYKE",							  	"NAZI",							  	"HITLER",							  	"BOMB",							  	"KILL",							  	"TERRORIST",							  	"FAG",							  	"FAGGOT",							  	"AL QAEDA",							  	"AL-QAEDA",							  	"PISTOL",							  	"RIFLE",							  	"SHOTGUN",							  	"GUN",							  	"MURDER"];		}		//- PRIVATE & PROTECTED METHODS ---------------------------------------------------------------------------				private static function prepareForComparison($s:String):String 		{			var a:Array = $s.split("\r");						$s = " " + a.join(" ").toUpperCase() + " ";						var punct:Array = [".", ",", "!", "?", "-", "(", ")", "_", "'", '"'];						for (var i:int = 0; i < punct.length; i++) 			{				$s = $s.split(punct[i]).join(" ");			}						return $s;		}				private static function parseYear($n:Number):Number 		{			if ($n > 100) 			{				return $n;			} 			else 			{				var today:Date = new Date();				var localYear:Number = (today.getFullYear() - 2000);								if ($n < localYear) 				{					return ($n + 2000);				} 				else 				{					return ($n + 1900);				}			}		}		//- PUBLIC & INTERNAL METHODS -----------------------------------------------------------------------------			/**		 * Tests the provided email address to see if it is valid.		 * 		 * @param $email The email address to test		 * 		 * @return Boolean		 */		public static function isValidEmail($email:String):Boolean 		{			var emailExpression:RegExp = /^[a-z][\w.-]+@\w[\w.-]+\.[\w.-]*[a-z][a-z]$/i;						if (isNotEmpty($email) && $email.length > 6 && $email.indexOf("@") != -1 && $email.indexOf("@") > 0)			{				return emailExpression.test($email);			}			else			{				return false;			}		}				/**		 * Tests a list of email addresses for validation.		 * 		 * @param $emailList The list of emails to test		 * @param $separator The character that separates the emails in the list		 * 		 * @return Boolean		 */		public static function isValidEmailList($emailList:String, $separator:String = ","):Boolean		{            var emails:Array = $emailList.split($separator);                        for each (var email:String in emails)            {                if (!isValidEmail(email.replace(/\s/, ""))) return false;            }                        return true;        }                /**         * Tests if the specified value is a valid US stage.         *          * @param $value The string to test         *          * @return Boolean         */        public static function isState($value:String):Boolean         {			return Boolean(STATES.indexOf(" " + $value.toUpperCase() + " ") != -1);		}				/**		 * Tests if the specified value is a valid zip code.		 * 		 * @param $value The string to test		 * 		 * @return Boolean		 */		public static function isZipCode($value:String):Boolean 		{			return ZIP_REG_EXP.test($value);		}				/**		 * Tests if the specified value is a valid phone number.		 * 		 * @param $value The string to test		 * 		 * @return Boolean		 */		public static function isPhone($value:String):Boolean 		{			$value = $value.split("-").join("");			$value = $value.split("(").join("");			$value = $value.split(")").join("");			$value = $value.split(".").join("");			$value = $value.split(" ").join("");						if (($value.substr(0, 1) == "1" && $value.length != 11) || ($value.substr(0, 1) != "1" && $value.length != 10)) 			{				return false;			}						return PHONE_REG_EXP.test($value);		}				/**		 * Tests if the specified value is a valid PO Box.		 * 		 * @param $value The string to test		 * 		 * @return Boolean		 */		public static function isPOBox($value:String):Boolean		{			return PO_BOX_REG_EXP.test($value);		}				/**		 * Tests if the specified string is empty/blank.		 * 		 * @param $s The string to test		 * 		 * @return Boolean		 */		public static function isNotEmpty($s:String):Boolean 		{			if ($s == null || $s == " " || $s == "") 			{				return false;			} 			else 			{				return true;			}		}				/**		 * Tests if the specified string is a valid URL.		 * Validate as "http://" or "https://".		 * 		 * @param $str  The string to test		 * 		 * @return Boolean		 */		public function isURL($str:String):Boolean		{			return ($str.substring(0, 7) == "http://" || $str.substring(0, 8) == "https://");		}				/**		 * Tests the specified string versus the list of clean words.  If an array of words to test against is not specified,		 * the default list of words (as defined in this class) is used.		 * 		 * @param $s The word to test		 * @param $wordList An array of words to test against		 * 		 * @return Boolean		 */		public static function isCleanFromList($s:String, $wordList:Array = null):Boolean 		{			$s = prepareForComparison($s);						var wordList:Array = ($wordList != null) ? $wordList : _illegalWords;						for (var i:int = 0; i < wordList.length; i++) 			{				if ($s.indexOf((" " + wordList[i].toUpperCase() + " ")) != -1) 				{					return false;				}			}						return true;		}				/**		 * Tests if the specified age passes the specified minimum.		 * 		 * @param $age The age to test		 * @param $month The month of the minimum age		 * @param $day The day of the minimum age		 * @param $year The year of the minimum age		 * 		 * @return Boolean		 */		public static function isMinimumAge($age:Number, $month:Number, $day:Number, $year:Number):Boolean 		{			var today:Date = new Date();			var year:Number = parseYear($year);			var yearDiff:Number = (today.getFullYear() - year);						if (yearDiff == $age) 			{				var monthDiff:Number = ((today.getMonth() + 1) - $month);								if (monthDiff == 0) 				{					var dayDiff:Number = (today.getDate() - $day);										if (dayDiff >= 0) 					{						return true;					} 					else 					{						return false;					}				} 				else if (monthDiff < 0) 				{					return false;				} 				else 				{					return true;				}			} 			else if (yearDiff < $age) 			{				return false;			} 			else 			{				return true;			}		}	//- EVENT HANDLERS ----------------------------------------------------------------------------------------				//- GETTERS & SETTERS -------------------------------------------------------------------------------------				//- HELPERS -----------------------------------------------------------------------------------------------			/**		 * @private		 */		public function toString():String		{			return getQualifiedClassName(this);		}	//- END CLASS ---------------------------------------------------------------------------------------------	}}